# 3.1. Глобальные скрипты (Autoloads)

Глобальные скрипты (синглтоны) являются ядром шаблона GOAT. Они доступны из любого места вашего кода, что делает их центральным элементом для управления состоянием игры, инвентарем и другими глобальными системами.

Вот список всех синглтонов, зарегистрированных в `project.godot`:

| Имя (Global Variable) | Путь к файлу                                                    | Назначение                                                                                                           |
| --------------------- | --------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `goat_audio_bus`      | `res://addons/goat/autoload/audio_bus.gd`                       | Управляет звуковыми шинами, громкостью и эффектами. Используйте его для проигрывания звуков.                         |
| `goat_locale`         | `res://addons/goat/autoload/locale.gd`                          | Отвечает за локализацию и перевод строк.                                                                             |
| `goat_utils`          | `res://addons/goat/globals/goat_utils.gd`                       | Содержит набор вспомогательных утилит и функций, которые могут понадобиться в разных частях проекта.                 |
| `goat`                | `res://addons/goat/globals/goat.gd`                             | Главный управляющий синглтон шаблона. Управляет режимами игры, настройками, глобальными параметрами.                 |
| `goat_state`          | `res://addons/goat/globals/goat_state.gd`                       | Глобальное хранилище состояния игры: флаги, переменные прогресса, условия для диалогов и интерактивных объектов.     |
| `goat_inventory`      | `res://addons/goat/globals/goat_inventory.gd`                   | Отвечает за инвентарь игрока. Позволяет добавлять, удалять и проверять наличие предметов.                            |
| `goat_interaction`    | `res://addons/goat/globals/goat_interaction.gd`                 | Управляет системой взаимодействия. Регистрирует все интерактивные объекты на сцене и обрабатывает клики мыши по ним. |
| `goat_voice`          | `res://addons/goat/globals/goat_voice.gd`                       | Система для проигрывания голосовых реплик персонажей.                                                                |
| `goat_settings`       | `res://addons/goat/globals/goat_settings.gd`                    | Управляет настройками игры (графика, звук, управление) и их сохранением/загрузкой.                                   |
| `DialogueManager`     | `res://addons/goat/addons/dialogue_manager/dialogue_manager.gd` | Мощный менеджер диалогов, основанный на кастомных ресурсах `.dialogue`. Обрабатывает ветвление, условия и реплики.   |

## Как их использовать?

Вы можете обратиться к любому из этих синглтонов напрямую по его имени из любого скрипта GDScript.

**Пример**:

```gdscript
# Проверяем, есть ли у игрока ключ в инвентаре
if goat_inventory.has('key'):
    # Устанавливаем флаг, что дверь открыта
    goat_state.set('is_door_open', true)
    # Проигрываем звук открытия двери
    goat_audio_bus.play('res://path/to/door_open_sound.ogg')
```

---

### Главный управляющий синглтон goat

`goat` — это центральный управляющий синглтон шаблона. Он отвечает за смену режимов игры, хранит глобальные параметры и предоставляет API для управления состоянием и настройками.

**Основные свойства:**
- `game_mode` — текущий режим игры (см. enum GameMode: NONE, EXPLORING, DETAILED_INTERACTION, INVENTORY, CONTEXT_INVENTORY, SETTINGS)
- `PLAYER_SPEED` — скорость передвижения игрока
- `BOTTOM_CAMERA_ANGLE`, `TOP_CAMERA_ANGLE`, `LEFT_CAMERA_ANGLE`, `RIGHT_CAMERA_ANGLE` — ограничения камеры
- `ALLOW_CAMERA_MOVEMENT_WHEN_VOICE_IS_PLAYING` — разрешить ли движение камеры во время озвучки
- `SCREENSHOT_DIRECTORY` — папка для скриншотов

**Основные методы:**
- `set_game_mode(new_game_mode)` — сменить режим игры (вызывает сигнал `game_mode_changed`)
- `get_game_resources_directory()` — получить путь к папке ресурсов игры
- `take_screenshot()` — сделать скриншот экрана
- `reset_game()` — сбросить состояние инвентаря и прогресса

**Сигналы:**
- `game_mode_changed(new_game_mode)` — вызывается при смене режима игры

**Примеры использования:**

```gdscript
# Переключить режим на инвентарь
if Input.is_action_just_pressed("goat_toggle_inventory"):
    goat.set_game_mode(goat.GameMode.INVENTORY)

# Получить путь к папке ресурсов
var res_dir = goat.get_game_resources_directory()

# Сделать скриншот
if Input.is_action_just_pressed("goat_screenshot"):
    goat.take_screenshot()
```

**Best practices:**
- Используйте goat для смены режимов и глобальных настроек, а не напрямую через переменные.
- Подписывайтесь на сигнал `game_mode_changed` для реакции на смену режима в UI и других системах.
- Все глобальные параметры (скорость, углы камеры и т.д.) выносите в goat для централизованного управления.

### Локализация и goat_locale

`goat_locale` — это синглтон для автоматической загрузки и управления переводами в проекте.

**Как работает:**
- При запуске игры автоматически загружает все файлы переводов (`.translation`) из папки `res://addons/goat/locale/`.
- При выходе из игры — выгружает переводы.
- Использует goat_utils для поиска и загрузки файлов.
- Интегрируется с TranslationServer Godot.

**Основные методы:**
- Для смены языка используйте стандартный API Godot:

```gdscript
TranslationServer.set_locale("en") # или "ru", "de" и т.д.
```

- Для получения текущего языка:

```gdscript
var current_locale = TranslationServer.get_locale()
```

**Пример использования в UI:**

```gdscript
# Перевести строку с ключом
var text = tr("MY_KEY")
label.text = text
```

**Best practices:**
- Все строки, требующие перевода, должны быть помечены через tr("...") или экспортированы в .pot/.csv для локализации.
- Для добавления новых языков — поместите .translation-файлы в папку `res://addons/goat/locale/` или используйте goat_utils.add_translations для пользовательских директорий.
- Для динамической смены языка используйте TranslationServer.set_locale и обновляйте UI вручную.

### Вспомогательные функции goat_utils

`goat_utils` — это набор утилит для работы с файлами, директориями и локализацией. Используется для загрузки ресурсов, работы с текстовыми файлами и управления переводами.

**Основные функции:**
- `list_directory(path)` — возвращает список файлов в директории.
- `load_text_file(path)` — загружает текстовый файл и возвращает его содержимое.
- `add_translations(translation_directory_path)` — добавляет все переводы из директории в TranslationServer.
- `remove_translations(translation_directory_path)` — удаляет переводы из TranslationServer.

**Примеры использования:**

```gdscript
# Получить список всех файлов в папке ресурсов
var files = goat_utils.list_directory("res://game/resources/")

# Загрузить текстовый файл
var text = goat_utils.load_text_file("res://game/data/intro.txt")

# Добавить все переводы из папки
goat_utils.add_translations("res://game/locale/")
```

Эти функции полезны для динамической загрузки ресурсов, работы с пользовательскими файлами и поддержки мультиязычности.

### Глобальное хранилище состояния goat_state: Архитектура порядка

Вместо того чтобы быть простым словарём, `goat_state` реализует более надёжный и строгий паттерн: **"Сначала объяви, потом используй"** (`Declare Before Use`). Это означает, что прежде чем вы сможете использовать любую глобальную переменную (например, `power_on` или `key_found`), вы **обязаны** сначала объявить её с начальным значением.

**Почему это так важно?**

1.  **Защита от опечаток**: Если вы попытаетесь получить доступ к переменной с опечаткой (например, `get_value("key_foud")` вместо `get_value("key_found")`), игра немедленно остановится с ошибкой `assert(false)`, и вы сразу же обнаружите баг. Без этой проверки вы бы молча получили `null`, что привело бы к скрытым и трудноуловимым ошибкам в логике.
2.  **Централизованное управление**: Все переменные состояния игры собраны в одном месте — в функции `_register_all_variables` внутри `goat_state.gd`. Это даёт вам полный обзор всех глобальных флагов и состояний, которые существуют в вашем проекте. Больше не нужно искать по всему коду, чтобы понять, какие переменные используются.
3.  **Ясность и предсказуемость**: Вы всегда знаете, какие переменные существуют и какие у них начальные значения. Это делает код более читаемым и предсказуемым для всей команды.

**Как правильно работать с `goat_state`**

**Шаг 1: Регистрация новой переменной (безопасный способ)**

Чтобы добавить новые переменные состояния, которые не будут затронуты при обновлении аддона GOAT, вам нужно создать `.json` файл в специальной директории вашего проекта.

1.  **Создайте директорию**: В вашем проекте (в корне, где `project.godot`) создайте следующую структуру папок: `goat/state/`.
    *   `res://goat/`
    *   `res://goat/state/`

2.  **Создайте JSON-файл**: Внутри папки `res://goat/state/` создайте новый файл с любым именем и расширением `.json`. Например, `my_game_state.json`.

3.  **Определите переменные**: Наполните этот файл парами "ключ-значение" в формате JSON. Ключ — это имя вашей переменной, а значение — её начальное состояние (может быть `false`, `true`, `0`, `"some_string"` и т.д.).

**Пример файла `res://goat/state/my_game_state.json`:**

```json
{
    "secret_document_found": false,
    "power_level": 0,
    "player_name": "Agent GOAT"
}
```

При запуске игры `goat_state` автоматически обнаружит этот файл, прочитает его и зарегистрирует все три переменные: `secret_document_found`, `power_level` и `player_name`.

Вы можете создавать сколько угодно таких `.json` файлов. Это позволяет вам логически разделять переменные состояния, относящиеся к разным частям вашей игры (например, `quests.json`, `puzzles.json` и т.д.).

Этот метод полностью безопасен при обновлениях, так как вы работаете только с файлами вашего собственного проекта, не затрагивая папку `addons/`.

**Шаг 2: Использование переменной в коде**

Теперь вы можете безопасно использовать эту переменную в любом скрипте вашего проекта.

-   **`set_value(variable_name, value)`**: Изменяет значение переменной. Это единственный правильный способ менять состояние.
-   **`get_value(variable_name)`**: Возвращает текущее значение переменной.

```gdscript
# В скрипте вашего интерактивного стола, где лежит документ
func _on_interact():
    # ... логика взаимодействия ...
    goat_state.set_value("secret_document_found", true)
    print("Игрок нашел секретный документ!")

# В скрипте NPC, который реагирует на это событие
func check_player_progress():
    # Проверяем состояние. Если документ найден, запускаем один диалог, если нет — другой.
    if goat_state.get_value("secret_document_found"):
        DialogueManager.start_dialogue(load("res://dialogues/npc_found_it.dialogue"))
    else:
        DialogueManager.start_dialogue(load("res://dialogues/npc_still_searching.dialogue"))

# Пример файла res://dialogues/npc_found_it.dialogue
# ~ start
# О, я вижу, ты нашел тот самый документ! Отлично.
# => END

# Пример файла res://dialogues/npc_still_searching.dialogue
# ~ start
# Все еще ищешь? Он где-то здесь...
# => END
```

**Шаг 3: Реакция на изменения с помощью сигналов**

`goat_state` имеет мощный сигнал `changed`, который срабатывает каждый раз, когда значение переменной меняется через `set_value`.

-   **Сигнал**: `changed(variable_name, from_value, to_value)`

Это позволяет создавать реактивную логику, где разные части игры могут "слушать" изменения состояния и реагировать на них без жёстких связей.

**Пример:** UI-элемент, который должен появиться, когда включается питание.

```gdscript
# В скрипте вашего UI-контроллера
func _ready():
    # Подписываемся на сигнал. Когда ЛЮБАЯ переменная изменится, вызовется _on_state_changed
    goat_state.changed.connect(_on_state_changed)

func _on_state_changed(variable_name: String, from_value, to_value):
    # Нас интересует только переменная "power_on"
    if variable_name == "power_on":
        if to_value == true:
            $PowerIndicator.show() # Показываем индикатор
        else:
            $PowerIndicator.hide() # Скрываем индикатор
```

Этот подход позволяет отделить логику состояния от логики отображения, делая ваш код чище и проще в поддержке.

**Ключевые методы и сигналы:**
- `set_value(variable_name, value)`: Установить значение **ранее зарегистрированной** переменной.
- `get_value(variable_name)`: Получить значение переменной.
- `has_variable(variable_name)`: Проверить, зарегистрирована ли переменная.
- `reset()`: Сбросить все переменные к их начальным значениям, указанным в `_register_all_variables`.
- `signal changed(variable_name, from_value, to_value)`: Срабатывает при изменении значения переменной.

**Итог:**

Никогда не используйте `goat_state` как "свободную" глобальную переменную. Всегда следуйте циклу **"Зарегистрируй -> Установи -> Прочитай"**. Это сохранит ваш проект чистым, предсказуемым и свободным от трудноуловимых багов.
