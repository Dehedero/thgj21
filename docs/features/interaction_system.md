# 3.3. Система взаимодействия

Система взаимодействия позволяет игроку взаимодействовать с объектами в игровом мире. Она управляется глобальным синглтоном `goat_interaction` и основана на двух основных типах сцен: `InteractiveItem` и `InteractiveScreen`.

## `InteractiveItem`

`InteractiveItem` — это базовый узел типа `StaticBody3D` или `RigidBody3D`, предназначенный для создания простых интерактивных объектов в мире. Он автоматически обрабатывает сигналы от `goat_interaction` и предоставляет следующие ключевые возможности:

-   **`unique_name`**: Уникальное имя объекта, используемое для его идентификации в системе.
-   **`action_name`**: Имя действия, которое отображается в UI (например, "Открыть", "Поговорить").
-   **`category`**: Категория для группировки похожих объектов.
-   **Сигналы**: Имеет встроенные сигналы `activated` и `activated_alternatively` для реализации игровой логики.

### Как создать InteractiveItem

1.  Создайте новую сцену, унаследованную от `addons/goat/main_scenes/InteractiveItem.tscn`.
2.  Добавьте в качестве дочернего узла вашу 3D-модель предмета.
3.  Настройте параметры в инспекторе.

### Настройки в инспекторе

*   `Unique Name`: **Обязательное поле.** Уникальное имя объекта, которое используется для его идентификации в системе. Например, `kitchen_door_key`.
*   `Item Type`: Определяет поведение предмета при активации.
    *   `NORMAL`: Обычный предмет, может быть использован многократно (например, выключатель света).
    *   `SINGLE_USE`: Одноразовый предмет. После использования отключается.
    *   `INVENTORY`: Предмет для инвентаря. При активации исчезает со сцены и добавляется в инвентарь игрока.
    *   `HAND`: Предмет, который можно взять в "руку" и затем положить в другом месте.
    *   `DIALOGUE`: Запускает диалог при активации.
*   `Inventory Item Name`: (Только для типа `INVENTORY` и `DIALOGUE`). Имя предмета, которое будет добавлено в инвентарь, или ID диалога для запуска.
*   `Collision Shape`: Форма коллайдера для взаимодействия. **Важно:** настройте ее так, чтобы она соответствовала видимой части вашего объекта.
*   `Sounds`: Массив звуков, которые будут проигрываться случайным образом при активации объекта.

### Как это работает?

Скрипт `InteractiveItem` автоматически регистрируется в `goat_interaction`. Когда игрок наводит прицел на объект, `goat_interaction` посылает сигнал `object_selected`, что заставляет иконку взаимодействия появиться. При клике (`goat_interact`) посылается сигнал `object_activated`, который запускает логику, определенную `Item Type`.

### Пример использования

Предположим, вы хотите создать ключ, который игрок может подобрать.

1.  Создаете унаследованную сцену `MyKey.tscn`.
2.  Устанавливаете `Unique Name` в "my_key".
3.  Устанавливаете `Item Type` в `INVENTORY`.
4.  Устанавливаете `Inventory Item Name` в "key_to_something".
5.  Размещаете `MyKey.tscn` на вашей игровой сцене.

Теперь, когда игрок активирует этот ключ, объект `MyKey` исчезнет, а в `goat_inventory` будет добавлен предмет "key_to_something".

## `InteractiveScreen`: Интерактивные 2D-интерфейсы в 3D-мире

`InteractiveScreen` — это мощный компонент, который позволяет встраивать любой 2D-интерфейс, созданный с помощью узлов Godot `Control`, прямо в 3D-сцену. Он представляет собой плоскую поверхность (экран), которая может принимать пользовательский ввод (движение мыши и клики) и отображать динамический 2D-контент. Это идеально подходит для создания компьютерных терминалов, информационных панелей, головоломок с интерфейсом и многого другого.

#### Как это работает?

В основе `InteractiveScreen` лежит узел `SubViewport`. Вот пошаговый процесс его работы:

1.  **Рендеринг контента**: Узел с 2D-контентом (например, ваша кастомная сцена с кнопками, текстом и т.д.), который вы добавляете как дочерний узел `Content`, перемещается внутрь `SubViewport`. `SubViewport` рендерит этот 2D-интерфейс в отдельную текстуру в реальном времени.
2.  **Отображение на 3D-поверхности**: Эта текстура (полученная из `SubViewport`) затем применяется к 3D-модели экрана (`ScreenSurface`) в качестве `albedo_texture`. Если включено свечение (`emission_energy > 0`), она также используется как карта излучения, создавая эффект светящегося экрана.
3.  **Трансляция ввода**: Когда игрок наводит курсор на `InteractiveScreen` в 3D-мире, система `goat_interaction` определяет глобальные координаты точки пересечения.
4.  **Преобразование координат**: Скрипт `InteractiveScreen` преобразует эти 3D-координаты в локальные 2D-координаты `SubViewport`.
5.  **Симуляция ввода**: Преобразованные координаты используются для создания и отправки фейковых событий ввода (`InputEventMouseMotion` для движения и `InputEventMouseButton` для кликов) напрямую в `SubViewport`. Это позволяет 2D-элементам внутри (кнопкам, слайдерам) реагировать так, как если бы они находились на обычном 2D-экране.

#### Ключевые параметры:

-   **`unique_name`** (`String`): Уникальный идентификатор экрана, по которому `goat_interaction` будет его находить.
-   **`content_size`** (`Vector2`): Размер 2D-контента в пикселях. Должен соответствовать размеру корневого узла вашего интерфейса. `SubViewport` будет иметь тот же размер.
-   **`emission_energy`** (`float`, 0-16): Сила свечения экрана. Если больше 0, материал экрана будет использовать текстуру контента как карту излучения.
-   **`unshaded`** (`bool`): Если `true`, материал экрана не будет подвержен влиянию освещения в сцене, сохраняя свои исходные цвета.

#### Как использовать:

1.  **Создайте сцену с 2D-интерфейсом**:
    *   Создайте новую сцену. Корневым узлом должен быть узел типа `Control` (например, `PanelContainer` или просто `Control`).
    *   Задайте его размер в инспекторе (`Layout -> Transform -> Size`). Этот размер вы позже укажете в `content_size`.
    *   Наполните сцену элементами управления: `Button`, `Label`, `TextureRect` и т.д.
    *   Подключите сигналы от кнопок (например, `pressed`) к скрипту на корневом узле для реализации логики.
    *   Сохраните эту сцену (например, `res://ui/my_terminal_ui.tscn`).

2.  **Настройте `InteractiveScreen` в 3D-сцене**:
    *   Добавьте узел `InteractiveScreen.tscn` в вашу 3D-сцену.
    *   В инспекторе `InteractiveScreen` задайте `unique_name` (например, "main_terminal").
    *   Установите `content_size` равным размеру вашего 2D-интерфейса.
    *   Добавьте экземпляр вашей сцены с интерфейсом (`my_terminal_ui.tscn`) как дочерний узел к `InteractiveScreen`. **Важно**: переименуйте корневой узел вашего интерфейса в `Content`.

    Структура в дереве сцены должна выглядеть так:
    ```
    - InteractiveScreen
      - ScreenSurface
      - SubViewport
      - InteractionIcon
      - Content (экземпляр вашей my_terminal_ui.tscn)
    ```

3.  **Готово!**
    Теперь, когда игрок в игре посмотрит на экран, `goat_interaction` обнаружит его. Движение мыши будет передаваться как движение курсора внутри 2D-интерфейса, а клик левой кнопкой мыши будет симулировать нажатие на элементы управления.

#### Лучшие практики и советы:

*   **Альтернативное взаимодействие (для использования предметов)**: `InteractiveScreen` по умолчанию использует альтернативное действие (правая кнопка мыши) для переключения в режим `CONTEXT_INVENTORY`. Этот режим предназначен для того, чтобы игрок мог "применить" предмет из своего инвентаря к экрану.
    *   **Пример**: У вас есть заблокированный терминал. Игрок нажимает на него ПКМ, открывается инвентарь, игрок выбирает "Карту доступа". Скрипт терминала может отловить это событие и разблокироваться.
    *   **Кастомизация**: Если вам нужна другая логика (например, по ПКМ приближать камеру или переключать режим экрана), вам следует создать свой скрипт, унаследованный от `InteractiveScreen.gd`, и в нем переопределить (`override`) функцию `_on_object_activated_alternatively`. Не изменяйте исходный файл в папке `addons`.

*   **Предотвращение звука по умолчанию**: `InteractiveScreen` вызывает `goat_voice.prevent_default()`, чтобы при клике на экран не проигрывался стандартный звук "клика". Если вы хотите добавить свой звук для кнопок интерфейса, делайте это внутри скрипта вашего 2D-интерфейса.
*   **Оптимизация**: `SubViewport` может быть ресурсоемким. Если у вас много интерактивных экранов, которые не видны игроку, рассмотрите возможность их отключения (`visible = false` или удаление из дерева), чтобы снизить нагрузку.

## Глобальный менеджер `goat_interaction`: Управление через категории

`goat_interaction` — это синглтон, управляющий всей логикой выбора и активации интерактивных объектов. Его ключевой особенностью является система **категорий**, которая позволяет отслеживать несколько интерактивных состояний одновременно, не допуская конфликтов между ними.

### Что такое категории и зачем они нужны?

Представьте, что `goat_interaction` — это диспетчерская. Без категорий у диспетчера был бы только один канал связи: он мог бы отслеживать только один "выбранный" объект во всей игре в один момент времени. Если игрок посмотрел на NPC, а затем на рычаг, то рычаг "перебил" бы NPC в этом единственном канале.

**Категории** решают эту проблему. Они работают как независимые каналы или "слоты" в этой диспетчерской. Для каждой категории (которую вы именуете простой строкой, например, `"npcs"` или `"terminals"`) `goat_interaction` хранит отдельную информацию о том, какой объект выбран и в какой точке.

Это позволяет разным системам вашей игры работать параллельно, не мешая друг другу.

**Основное преимущество:** Разные части вашего кода могут работать со своими собственными, изолированными группами интерактивных объектов.

### Практический пример: NPC и терминал

Рассмотрим сцену, где NPC стоит рядом с компьютерным терминалом.

1.  **Основное взаимодействие (категория `"default"`):**
    *   Основной `RayCast` игрока, который следует за прицелом, используется для прямого взаимодействия — поговорить, нажать и т.д. Этот `RayCast` будет выбирать объекты в категории `"default"`.
    *   Когда игрок смотрит на NPC, `RayCast` обнаруживает его и вызывает:
        ```gdscript
        goat_interaction.select_object("npc_bob", point, "default")
        ```
    *   Интерфейс игрока (UI) слушает категорию `"default"` и, видя, что выбран `npc_bob`, показывает подсказку "Поговорить с Бобом".

2.  **Контекстное взаимодействие (категория `"context"`):**
    *   Предположим, у нас есть система, которая должна знать, рядом с каким терминалом находится игрок, даже если он на него не смотрит. Для этого мы можем использовать `Area3D` вокруг терминала.
    *   Когда игрок входит в `Area3D` терминала, код терминала вызывает:
        ```gdscript
        goat_interaction.select_object("main_server_terminal", self.global_transform.origin, "context")
        ```
    *   Когда игрок выходит, терминал вызывает `goat_interaction.deselect_object("context")`.

**Результат:**

Теперь в `goat_interaction` одновременно хранятся два состояния:
*   В категории `"default"` выбран `npc_bob`.
*   В категории `"context"` выбран `main_server_terminal`.

Игровой UI может безопасно показывать подсказку "Поговорить", основываясь на данных из категории `"default"`. В то же время, если игрок откроет, например, меню взлома, это меню может проверить категорию `"context"`, чтобы узнать, какой терминал доступен для взлома. Эти две системы не конфликтуют.

### Основные сигналы

- `object_selected(object_name, point)` — объект выбран (прицел наведен), point — точка взаимодействия.
- `object_deselected(object_name)` — объект больше не выбран.
- `object_activated(object_name, point)` — объект активирован (ЛКМ).
- `object_activated_alternatively(object_name, point)` — альтернативная активация (ПКМ или другое действие).
- `object_enabled(object_name)` — объект включен для взаимодействия.
- `object_disabled(object_name)` — объект выключен для взаимодействия.

### Основные методы

- `get_selected_object(category: String)` — получить имя выбранного объекта в указанной категории.
- `get_selected_point(category: String)` — получить точку взаимодействия с выбранным объектом в указанной категории.
- `select_object(object_name: String, point: Vector3, category: String)` — выбрать объект в указанной категории.
- `deselect_object(category: String)` — снять выбор с объекта в указанной категории.
- `activate_object(category: String)` — активировать выбранный объект в указанной категории.
- `alternatively_activate_object(category: String)` — выполнить альтернативную активацию для объекта в указанной категории.
- `enable_object(object_name)` / `disable_object(object_name)` — включить/выключить объект для взаимодействия (действует глобально, вне категорий).

### Примеры использования

```gdscript
# В скрипте UI, который показывает подсказку для основного действия
func _process(delta):
    var selected_object = goat_interaction.get_selected_object("default")
    if selected_object:
        action_label.text = "Нажмите Е, чтобы взаимодействовать с " + selected_object
    else:
        action_label.text = ""

# В скрипте Area3D вокруг терминала
func _on_body_entered(body):
    if body.is_in_group("player"):
        # Сообщаем системе, что игрок теперь в контексте этого терминала
        goat_interaction.select_object("terminal_01", self.global_transform.origin, "context")

func _on_body_exited(body):
    if body.is_in_group("player"):
        goat_interaction.deselect_object("context")

# В скрипте меню взлома, которое открывается по кнопке "H"
func _unhandled_input(event):
    if event.is_action_pressed("hack"):
        var terminal_to_hack = goat_interaction.get_selected_object("context")
        if terminal_to_hack:
            print("Начинаем взлом терминала: ", terminal_to_hack)
        else:
            print("Нет терминала для взлома в пределах досягаемости.")
```

### Лучшие практики
- Используйте категорию `"default"` для основного, прямого взаимодействия игрока через прицел.
- Создавайте осмысленные имена для других категорий (`"context"`, `"mission_targets"`, `"ui_hover"`), чтобы ваш код было легко читать.
- Всегда снимайте выбор с объекта (`deselect_object`), когда взаимодействие с ним больше невозможно (например, когда игрок выходит из триггера `Area3D`).
- Помните, что сигналы (`object_selected`, `object_activated` и др.) не содержат информации о категории. Они сообщают только *какой* объект был затронут. Логика, зависящая от категории, должна опрашивать `goat_interaction` напрямую (используя методы `get_selected_object`).

Подробнее о RayCast3D.tscn см. [Вспомогательные UI-сцены](./helper_scenes.md#raycast3d).
